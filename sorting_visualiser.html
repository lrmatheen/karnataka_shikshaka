<!doctype html>
<html>
<head>
<meta charset="utf-8"/>
<title>Sorting Visualizer</title>
<style>
  :root{
    --box-w: 92px;
    --box-h: 72px;
    --gap: 18px;
    --bg-unsorted: #8DD3FF;  /* blue */
    --bg-sorted: #A5F2A5;    /* green */
    --text: #0a0a0a;
    --swap-color: #E53935;   /* red */
    --compare-color: #1E88E5;/* blue (arrow color only) */
    --move-color: #FB8C00;   /* orange */
    --arrow-width: 3;
  }
  body { font-family: system-ui, Arial; margin:20px; color:var(--text) }
  h2 { margin: 0 0 10px 0; }
  #controls { margin-bottom:12px; display:flex; gap:8px; align-items:center; flex-wrap:wrap;}
  input[type="text"]{ padding:6px; font-size:15px; width:420px }
  select{ padding:6px; font-size:15px }
  button{ padding:8px 12px; font-size:15px; cursor:pointer }
  #stageWrap { width:100%; max-width:980px; background: #fff; padding:10px; box-sizing:border-box; position:relative; }
  #stage { position:relative; height:240px; min-height:240px; }
  .box {
    position:absolute;
    width:var(--box-w);
    height:var(--box-h);
    border:2px solid #222;
    border-radius:8px;
    display:flex;
    align-items:center;
    justify-content:center;
    font-weight:800;
    font-size:24px;
    color:#030303;
    transition: left 250ms, top 250ms, background 200ms;
    box-sizing:border-box;
  }
  .unsorted { background: var(--bg-unsorted); }
  .sorted   { background: var(--bg-sorted); }
  .compare  { background: var(--bg-unsorted); } /* visually same background as unsorted */
  svg { position:absolute; left:0; top:0; pointer-events:none; overflow:visible; }
  #playControls { margin-top:10px; display:flex; gap:8px; align-items:center; flex-wrap:wrap; }
  #status { font-weight:700 }
  #passStep { font-weight:700; color: #1a237e; min-width:180px; text-align:center; }
  label.small { font-size:13px; color:#333; margin-left:8px }

  /* PASS COMPLETED banner */
  .preview-banner {
    position:absolute;
    left:50%;
    transform:translateX(-50%);
    top:12px;
    background: rgba(26,35,126,0.06);
    border:1px solid rgba(26,35,126,0.12);
    padding:6px 12px;
    border-radius:8px;
    font-weight:800;
    color:#1a237e;
    pointer-events:none;
    z-index:20;
    letter-spacing:0.6px;
  }

  /* Arrow flow animation - uses stroke-dashoffset animation */
  @keyframes flow {
    to { stroke-dashoffset: 0; }
  }
</style>
</head>
<body>

<h2>Sorting Visualizer</h2>

<div id="controls">
  <label>Values:</label>
  <input id="inputArray" type="text" value="4, 3, 10, 1, -6, 2" />
  <label>Algorithm:</label>
  <select id="algo">
    <option value="insertion">Insertion</option>
    <option value="bubble">Bubble</option>
    <option value="selection">Selection</option>
  </select>

  <button id="runBtn">Run</button>
  <button id="resetBtn">Reset</button>

  <span class="small">Speed:</span>
  <input id="speed" type="range" min="100" max="1500" step="50" value="600" />
  <span id="speedLabel" class="small">600ms</span>
</div>

<div id="stageWrap">
  <div id="stage"></div>
  <svg id="svgLayer"></svg>
  <!-- preview banner will be injected here when showing pass-preview -->
</div>

<div id="playControls">
  <button id="prevBtn">Prev</button>
  <button id="playBtn">Play</button>
  <button id="nextBtn">Next</button>
  <span id="status">Step: 0 / 0</span>
  <span id="passStep">Pass: 0 • Step: 0</span>
</div>

<script>
/* ---------- Layout params ---------- */
const BOX_W = 92, BOX_H = 72, GAP = 18;
const X0 = 18, Y0 = 80;

const stage = document.getElementById('stage');
const svg   = document.getElementById('svgLayer');
const stageWrap = document.getElementById('stageWrap');
let boxes = [];   // DOM elements for boxes
let steps = [];   // array of step objects
let idx = 0;
let timer = null;
let playing = false;

/* ---------- Helpers ---------- */
function parseInputArray(txt){
  return txt.split(',').map(s=>Number(s.trim())).filter(n=>!Number.isNaN(n));
}

function sizeSvg(){
  const r = stage.getBoundingClientRect();
  svg.setAttribute('width', r.width);
  svg.setAttribute('height', r.height);
  svg.style.left = stage.offsetLeft + 'px';
  svg.style.top  = stage.offsetTop + 'px';
}

function clearSvg(){
  while(svg.firstChild) svg.removeChild(svg.firstChild);
}

/* create boxes representing 'values' on stage (absolute positioned) */
function createBoxes(values){
  boxes.forEach(b=>b.remove());
  boxes = [];
  for(let i=0;i<values.length;i++){
    const d = document.createElement('div');
    d.className = 'box unsorted';
    d.style.left = (X0 + i*(BOX_W + GAP)) + 'px';
    d.style.top  = Y0 + 'px';
    d.textContent = values[i];
    stage.appendChild(d);
    boxes.push(d);
  }
  // ensure svg sized after DOM insertion
  setTimeout(sizeSvg, 20);
}

/*
  Update boxes:
  - values: array of numbers
  - sorted: null | {type:'prefix', end: idx} | {type:'suffix', start: idx}
  - compare: optional [i,j] indices involved in a compare (we do not change bg for compare)
*/
function updateBoxes(values, sorted=null, compare=null){
  for(let i=0;i<values.length;i++){
    boxes[i].textContent = values[i];
    boxes[i].style.left = (X0 + i*(BOX_W + GAP)) + 'px';

    // default unsorted
    let isSorted = false;
    if(sorted){
      if(sorted.type === 'prefix' && typeof sorted.end === 'number'){
        if(i <= sorted.end) isSorted = true;
      } else if(sorted.type === 'suffix' && typeof sorted.start === 'number'){
        if(i >= sorted.start) isSorted = true;
      }
    }

    if(isSorted){
      boxes[i].className = 'box sorted';
    } else {
      boxes[i].className = 'box unsorted';
    }

    // Add/remove compare class for optional subtle styling (but bg unchanged)
    if(compare && (i === compare[0] || i === compare[1])){
      boxes[i].classList.add('compare');
    } else {
      boxes[i].classList.remove('compare');
    }
  }
}

/* create SVG marker with arrowhead */
function ensureMarker(id, color) {
  const ns = "http://www.w3.org/2000/svg";

  // If already created, stop
  if (document.getElementById(id + "_L") && document.getElementById(id + "_R"))
    return id;

  const defs = document.createElementNS(ns, "defs");

  // RIGHT arrowhead → 
  const markerR = document.createElementNS(ns, "marker");
  markerR.setAttribute("id", id + "_R");
  markerR.setAttribute("markerWidth", "12");
  markerR.setAttribute("markerHeight", "12");
  markerR.setAttribute("refX", "12");
  markerR.setAttribute("refY", "6");
  markerR.setAttribute("orient", "auto");

  const pathR = document.createElementNS(ns, "path");
  pathR.setAttribute("d", "M0,0 L12,6 L0,12 z");
  pathR.setAttribute("fill", color);
  markerR.appendChild(pathR);

  // LEFT arrowhead ← 
  const markerL = document.createElementNS(ns, "marker");
  markerL.setAttribute("id", id + "_L");
  markerL.setAttribute("markerWidth", "12");
  markerL.setAttribute("markerHeight", "12");
  markerL.setAttribute("refX", "0");
  markerL.setAttribute("refY", "6");
  markerL.setAttribute("orient", "auto");

  const pathL = document.createElementNS(ns, "path");
  pathL.setAttribute("d", "M12,0 L0,6 L12,12 z");
  pathL.setAttribute("fill", color);
  markerL.appendChild(pathL);

  defs.appendChild(markerR);
  defs.appendChild(markerL);
  svg.appendChild(defs);

  return id;
}


/* draw curved arrow with color/style/type.
   type: 'swap' -> red solid double-headed
         'compare' -> blue dashed double-headed
         'move' -> orange solid double-headed (insertion shifts)
*/
function drawCurvedArrow(i, j, type='swap', label=''){
  clearSvg();
  if(i==null || j==null) return;
  if(!boxes[i] || !boxes[j]) return;

  const r = stage.getBoundingClientRect();
  const b0 = boxes[i].getBoundingClientRect();
  const b1 = boxes[j].getBoundingClientRect();
  const x1 = (b0.left - r.left) + b0.width/2;
  const x2 = (b1.left - r.left) + b1.width/2;
  const y  = (b0.top - r.top) - 6;
  const mx = (x1 + x2)/2;
  const dist = Math.abs(x2 - x1);
  const ctrlY = y - Math.max(50, dist*0.25);

  const ns = "http://www.w3.org/2000/svg";
  const path = document.createElementNS(ns,'path');
  const d = `M ${x1} ${y} Q ${mx} ${ctrlY} ${x2} ${y}`;
  path.setAttribute('d', d);
  path.setAttribute('fill', 'none');
  path.setAttribute('stroke-linecap', 'round');

  let strokeColor = getComputedStyle(document.documentElement).getPropertyValue('--swap-color').trim();
  let strokeWidth = Number(getComputedStyle(document.documentElement).getPropertyValue('--arrow-width'));
  let dash = '';
  let markerId = 'arrowHeadSwap';

  if(type === 'compare'){
    strokeColor = getComputedStyle(document.documentElement).getPropertyValue('--compare-color').trim();
    dash = '6,6';
    markerId = 'arrowHeadCompare';
  } else if(type === 'move'){
    strokeColor = getComputedStyle(document.documentElement).getPropertyValue('--move-color').trim();
    markerId = 'arrowHeadMove';
  } else { // swap
    markerId = 'arrowHeadSwap';
  }

  // ensure marker for chosen color exists
  ensureMarker(markerId, strokeColor);

  path.setAttribute('stroke', strokeColor);
  path.setAttribute('stroke-width', strokeWidth);
  if(dash) path.setAttribute('stroke-dasharray', dash);

  // BOTH arrowheads
  path.setAttribute('marker-start', `url(#${markerId})`);
  path.setAttribute('marker-end', `url(#${markerId})`);

  // animated flow
  const speed = Number(document.getElementById('speed').value) || 600;
  const totalLen = 1200;
  path.setAttribute('stroke-dasharray', totalLen);
  path.setAttribute('stroke-dashoffset', totalLen);
  path.style.animation = `flow ${speed}ms linear forwards`;

  svg.appendChild(path);

  if(label){
    const txt = document.createElementNS(ns,'text');
    txt.setAttribute('x', mx);
    txt.setAttribute('y', ctrlY - 8);
    txt.setAttribute('text-anchor', 'middle');
    txt.setAttribute('font-size', '13');
    txt.setAttribute('font-weight', '600');
    txt.textContent = label;
    svg.appendChild(txt);
  }
}

/* ---------- Sorting step generators (with types) ----------
   Each step object format:
   {
     after: [...],
     swap: [i,j] | null,
     type: 'compare'|'swap'|'move'|'pass-end'|'pass-preview'|'initial'|'final',
     pass: n,
     stepInPass: k,
     sorted: null | {type:'prefix', end: idx} | {type:'suffix', start: idx}
   }
*/

/* ---------- computeInsertion (left unchanged) ---------- */
function computeInsertion(arr){
  let a = arr.slice();
  const S = [];
  const n = a.length;

  // Initial: first element considered sorted
  S.push({
    after: a.slice(),
    swap: null,
    type: 'initial',
    pass: 0,
    stepInPass: 0,
    sorted: { type: 'prefix', end: 0 }
  });

  for(let pass = 1; pass < n; pass++){
    let k = pass;
    let stepInPass = 0;

    // initial compare: between k-1 and k, sorted prefix is 0..(pass-1)
    if(k-1 >= 0){
      stepInPass++;
      S.push({
        after: a.slice(),
        swap: [k-1, k],
        type: 'compare',
        pass: pass,
        stepInPass,
        sorted: { type: 'prefix', end: pass - 1 }
      });
    }

    while(k > 0 && a[k] < a[k-1]){
      [a[k], a[k-1]] = [a[k-1], a[k]];
      stepInPass++;
      S.push({
        after: a.slice(),
        swap: [k-1, k],
        type: 'move',
        pass: pass,
        stepInPass,
        sorted: { type: 'prefix', end: pass - 1 }
      });
      k--;

      if(k-1 >= 0){
        stepInPass++;
        S.push({
          after: a.slice(),
          swap: [k-1, k],
          type: 'compare',
          pass: pass,
          stepInPass,
          sorted: { type: 'prefix', end: pass - 1 }
        });
      }
    }

    // pass-end: prefix extended
    S.push({
      after: a.slice(),
      swap: null,
      type: 'pass-end',
      pass: pass,
      stepInPass: stepInPass + 1,
      sorted: { type: 'prefix', end: pass }
    });

    // preview (start of next pass) — show PASS COMPLETED (only if not final)
    if(pass < n - 1){
      S.push({
        after: a.slice(),
        swap: null,
        type: 'pass-preview',
        pass: pass,
        stepInPass: 0,
        sorted: { type: 'prefix', end: pass }
      });
    }
  }

  S.push({
    after: a.slice(),
    swap: null,
    type: 'final',
    pass: n-1,
    stepInPass: 0,
    sorted: { type: 'prefix', end: n-1 }
  });

  return S;
}

/* ---------- cmputeBubble (ONLY this function changed) ----------
   Behavior:
   - During pass p, keep previously-fixed suffix green:
       sorted.start = n - (p - 1)  (which equals n when none are fixed)
   - After inner loop, push a single pass-preview step (no stray step:0)
       preview sorted.start = n - p
*/
function cmputeBubble(arr){
  let a = arr.slice();
  let S = [];
  let n = a.length;

  // initial state: nothing sorted
  S.push({
    after: a.slice(),
    swap: null,
    type: 'initial',
    pass: 0,
    stepInPass: 0,
    sorted: { type: 'suffix', start: n } // none sorted
  });

  for (let pass = 1; pass <= n - 1; pass++) {
    let stepInPass = 0;

    for (let j = 0; j < n - pass; j++) {
      stepInPass++;

      // compute suffix start that is already fixed from previous passes
      const alreadyFixedStart = n - (pass - 1); // equals n when none fixed

      // Compare event: show previously fixed suffix green, but not the new one yet
      S.push({
        after: a.slice(),
        swap: [j, j+1],
        type: "compare",
        pass,
        stepInPass,
        sorted: { type: 'suffix', start: alreadyFixedStart }
      });

      // Swap event
      if (a[j] > a[j+1]) {
        [a[j], a[j+1]] = [a[j+1], a[j]];

        S.push({
          after: a.slice(),
          swap: [j, j+1],
          type: "swap",
          pass,
          stepInPass,
          sorted: { type: 'suffix', start: alreadyFixedStart }
        });
      }
    }

    // After the pass completes, the newly-fixed element index is n - pass
    // Instead of pushing a stray step:0 we push a single pass-preview step which shows PASS COMPLETED
    S.push({
      after: a.slice(),
      swap: null,
      type: "pass-preview",
      pass,
      stepInPass: 0,
      sorted: { type: 'suffix', start: n - pass } // newly fixed suffix
    });

    // (no separate pass-end step so there's no stray "Step: 0" render)
  }

  // final state: everything sorted (suffix start 0)
  S.push({
    after: a.slice(),
    swap: null,
    type: "final",
    pass: n-1,
    stepInPass: 0,
    sorted: { type: 'suffix', start: 0 }
  });

  return S;
}

/* ---------- computeSelection (left unchanged) ---------- */
function computeSelection(arr){
  let a=arr.slice(), S=[], n=a.length;

  // initial state: none sorted
  S.push({
    after: a.slice(),
    swap: null,
    type: 'initial',
    pass: 0,
    stepInPass: 0,
    sorted: { type: 'prefix', end: -1 }
  });

  for(let i=0;i<n-1;i++){
    let minIdx = i, stepInPass = 0;

    for(let j=i+1;j<n;j++){
      stepInPass++;
      S.push({
        after: a.slice(),
        swap: [minIdx, j],
        type: 'compare',
        pass: i+1,
        stepInPass,
        sorted: { type: 'prefix', end: i-1 } // before placing i
      });

      if(a[j] < a[minIdx]){
        minIdx = j;
      }
    }

    if(minIdx !== i){
      [a[i], a[minIdx]] = [a[minIdx], a[i]];
      stepInPass++;
      S.push({
        after: a.slice(),
        swap: [i, minIdx],
        type: 'swap',
        pass: i+1,
        stepInPass,
        sorted: { type: 'prefix', end: i }
      });
    } else {
      S.push({
        after: a.slice(),
        swap: null,
        type: 'pass-end',
        pass: i+1,
        stepInPass,
        sorted: { type: 'prefix', end: i }
      });
    }

    // PASS PREVIEW — show PASS COMPLETED (prefix extended)
    if(i < n - 2){
      S.push({
        after: a.slice(),
        swap: null,
        type: 'pass-preview',
        pass: i+1,
        stepInPass: 0,
        sorted: { type: 'prefix', end: i }
      });
    }
  }

  S.push({after:a.slice(),swap:null,type:'final',pass:n-1,stepInPass:0,sorted:{type:'prefix',end:n-1}});
  return S;
}

/* ---------- Controller / rendering ---------- */

function prepareSteps(values, algo){
  if(algo==='insertion') return computeInsertion(values);
  if(algo==='bubble') return cmputeBubble(values); // uses the function name you provided
  if(algo==='selection') return computeSelection(values);
  return [];
}

/* remove any existing preview banner */
function removePreviewBanner(){
  const existing = document.getElementById('previewBanner');
  if(existing) existing.remove();
}

function showPreviewBanner(){
  removePreviewBanner();
  const b = document.createElement('div');
  b.id = 'previewBanner';
  b.className = 'preview-banner';
  b.textContent = 'PASS COMPLETED';
  stageWrap.appendChild(b);
}

function renderIndex(i){
  if(!steps.length) return;
  if(i<0) i=0;
  if(i>=steps.length) i=steps.length-1;
  idx = i;
  const s = steps[i];
  if(!boxes.length || boxes.length !== s.after.length) createBoxes(s.after);

  // For compare arrows: we draw arrows when swap array is present for compare/move/swap
  const compare = (s.type === 'compare' && s.swap) ? s.swap : (s.swap && s.type!=='compare' ? s.swap : null);

  // Update boxes with s.sorted (may be null)
  updateBoxes(s.after, s.sorted, (s.type === 'compare' && s.swap) ? s.swap : null);

  // Handle preview banner and passStep text
  removePreviewBanner();
  if(s.type === 'pass-preview'){
    // show PASS COMPLETED banner and change passStep text
    showPreviewBanner();
    document.getElementById('passStep').textContent = 'PASS COMPLETED';
    // clear arrows
    clearSvg();
  } else {
    // Normal text for pass/step
    document.getElementById('passStep').textContent = `Pass: ${s.pass} • Step: ${s.stepInPass}`;
  }

  // Draw arrow if appropriate (not during pass-preview)
  if (s.type !== 'pass-preview' && s.swap && s.swap[0] !== s.swap[1]) {
    if (s.type === 'swap') drawCurvedArrow(s.swap[0], s.swap[1], 'swap', 'swap');
    else if (s.type === 'compare') drawCurvedArrow(s.swap[0], s.swap[1], 'compare', 'compare');
    else if (s.type === 'move') drawCurvedArrow(s.swap[0], s.swap[1], 'move', 'shift');
    else drawCurvedArrow(s.swap[0], s.swap[1], 'compare', '');
  } else {
    if(s.type !== 'pass-preview') clearSvg();
  }

  document.getElementById('status').textContent = `Step: ${i+1} / ${steps.length}`;
}

/* ---------- Playback ---------- */
function stopPlayback(){
  if(timer) clearInterval(timer);
  playing=false;
  document.getElementById('playBtn').textContent='Play';
}

function startPlayback(){
  stopPlayback();
  playing=true;
  document.getElementById('playBtn').textContent='Pause';
  const speed = Number(document.getElementById('speed').value);
  timer = setInterval(()=>{
    if(idx < steps.length-1) renderIndex(idx+1);
    else stopPlayback();
  }, speed);
}

/* ---------- UI wiring ---------- */

window.addEventListener('resize', ()=>{ sizeSvg(); });

document.getElementById('runBtn').addEventListener('click', ()=>{
  stopPlayback();
  clearSvg();
  removePreviewBanner();
  const values = parseInputArray(document.getElementById('inputArray').value);
  if(values.length === 0){ alert('Enter at least one number.'); return; }
  steps = prepareSteps(values, document.getElementById('algo').value);
  renderIndex(0);
});

document.getElementById('resetBtn').addEventListener('click', ()=>{
  stopPlayback();
  steps = []; idx = 0; clearSvg();
  boxes.forEach(b=>b.remove()); boxes = [];
  removePreviewBanner();
  document.getElementById('status').textContent = 'Step: 0 / 0';
  document.getElementById('passStep').textContent = 'Pass: 0 • Step: 0';
});

document.getElementById('prevBtn').addEventListener('click', ()=>{ stopPlayback(); renderIndex(Math.max(0, idx-1)); });
document.getElementById('nextBtn').addEventListener('click', ()=>{ stopPlayback(); renderIndex(Math.min(steps.length-1, idx+1)); });
document.getElementById('playBtn').addEventListener('click', ()=>{ if(playing) stopPlayback(); else startPlayback(); });
document.getElementById('speed').addEventListener('input', e=>{
  document.getElementById('speedLabel').textContent = e.target.value + 'ms';
  if(playing){ startPlayback(); }
});

/* initial sizing */
sizeSvg();

</script>
</body>
</html>
